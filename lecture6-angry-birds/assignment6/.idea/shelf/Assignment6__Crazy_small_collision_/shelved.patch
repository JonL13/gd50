Index: main.lua
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>--[[\n    GD50\n    Angry Birds\n\n    Author: Colton Ogden\n    cogden@cs50.harvard.edu\n\n    Released by Rovio in 2009, Angry Birds took the mobile gaming scene by storm back\n    when it was still arguably in its infancy. Using the simple gameplay mechanic of\n    slingshotting birds into fortresses of various materials housing targeted pigs,\n    Angry Birds succeeded with its optimized formula for on-the-go gameplay. It's an\n    excellent showcase of the ubiquitous Box2D physics library, the most widely used\n    physics library of its kind, which is also open source. This \"clone\" of Angry Birds\n    doesn't contain nearly the plethora of features as the original series of games\n    it's based on but does use Box2D to showcase the fundamental setup of what the game\n    looks like and how to use a subset of the physics library's features.\n\n    Music credit:\n    https://freesound.org/people/tyops/sounds/348166/\n\n    Artwork credit:\n    https://opengameart.org/content/physics-assets\n]]\n\nrequire 'src/Dependencies'\n\nfunction love.load()\n    math.randomseed(os.time())\n    love.graphics.setDefaultFilter('nearest', 'nearest')\n    love.window.setTitle('Angry 50')\n\n    push:setupScreen(VIRTUAL_WIDTH, VIRTUAL_HEIGHT, WINDOW_WIDTH, WINDOW_HEIGHT, {\n        fullscreen = false,\n        vsync = true,\n        resizable = true\n    })\n\n    gStateMachine = StateMachine {\n        ['start'] = function() return StartState() end,\n        ['play'] = function() return PlayState() end\n    }\n    gStateMachine:change('start')\n\n    love.audio.setVolume(.1)\n\n    gSounds['music']:setLooping(true)\n    --gSounds['music']:setVolume(.08)\n    gSounds['music']:play()\n\n    love.keyboard.keysPressed = {}\n    love.mouse.keysPressed = {}\n    love.mouse.keysReleased = {}\n\n    paused = false\nend\n\nfunction push.resize(w, h)\n    push:resize(w, h)\nend\n\nfunction love.keypressed(key)\n    if key == 'p' then\n        paused = not paused\n    end\n\n    love.keyboard.keysPressed[key] = true\nend\n\nfunction love.mousepressed(x, y, key)\n    love.mouse.keysPressed[key] = true\nend\n\nfunction love.mousereleased(x, y, key)\n    love.mouse.keysReleased[key] = true \nend\n\nfunction love.keyboard.wasPressed(key)\n    return love.keyboard.keysPressed[key]\nend\n\nfunction love.mouse.wasPressed(key)\n    return love.mouse.keysPressed[key]\nend\n\nfunction love.mouse.wasReleased(key)\n    return love.mouse.keysReleased[key]\nend\n\nfunction love.update(dt)\n    if not paused then\n        gStateMachine:update(dt)\n\n        love.keyboard.keysPressed = {}\n        love.mouse.keysPressed = {}\n        love.mouse.keysReleased = {}\n    end\nend\n\nfunction love.draw()\n    push:start()\n    gStateMachine:render()\n    push:finish()\nend
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- main.lua	(revision 2adefa677b5e80aabebe1cb6173c72c4d1b493d7)
+++ main.lua	(date 1590349253343)
@@ -44,7 +44,6 @@
     love.audio.setVolume(.1)
 
     gSounds['music']:setLooping(true)
-    --gSounds['music']:setVolume(.08)
     gSounds['music']:play()
 
     love.keyboard.keysPressed = {}
Index: src/Level.lua
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>--[[\n    GD50\n    Angry Birds\n\n    Author: Colton Ogden\n    cogden@cs50.harvard.edu\n]]\n\nLevel = Class{}\n\nfunction Level:init()\n    -- create a new \"world\" (where physics take place), with no x gravity\n    -- and 30 units of Y gravity (for downward force)\n    self.world = love.physics.newWorld(0, 300)\n\n    -- bodies we will destroy after the world update cycle; destroying these in the\n    -- actual collision callbacks can cause stack overflow and other errors\n    self.destroyedBodies = {}\n\n    -- define collision callbacks for our world; the World object expects four,\n    -- one for different stages of any given collision\n    function beginContact(a, b, coll)\n        local types = {}\n        types[a:getUserData()] = true\n        types[b:getUserData()] = true\n\n        -- if we collided between both an alien and an obstacle...\n        if types['Obstacle'] and types['Player'] then\n\n            -- destroy the obstacle if player's combined velocity is high enough\n            if a:getUserData() == 'Obstacle' then\n                local velX, velY = b:getBody():getLinearVelocity()\n                local sumVel = math.abs(velX) + math.abs(velY)\n\n                if sumVel > 20 then\n                    table.insert(self.destroyedBodies, a:getBody())\n                end\n            else\n                local velX, velY = a:getBody():getLinearVelocity()\n                local sumVel = math.abs(velX) + math.abs(velY)\n\n                if sumVel > 20 then\n                    table.insert(self.destroyedBodies, b:getBody())\n                end\n            end\n        end\n\n        -- if we collided between an obstacle and an alien, as by debris falling...\n        if types['Obstacle'] and types['Alien'] then\n\n            -- destroy the alien if falling debris is falling fast enough\n            if a:getUserData() == 'Obstacle' then\n                local velX, velY = a:getBody():getLinearVelocity()\n                local sumVel = math.abs(velX) + math.abs(velY)\n\n                if sumVel > 20 then\n                    table.insert(self.destroyedBodies, b:getBody())\n                end\n            else\n                local velX, velY = b:getBody():getLinearVelocity()\n                local sumVel = math.abs(velX) + math.abs(velY)\n\n                if sumVel > 20 then\n                    table.insert(self.destroyedBodies, a:getBody())\n                end\n            end\n        end\n\n        -- if we collided between the player and the alien...\n        if types['Player'] and types['Alien'] then\n\n            -- destroy the alien if player is traveling fast enough\n            if a:getUserData() == 'Player' then\n                local velX, velY = a:getBody():getLinearVelocity()\n                local sumVel = math.abs(velX) + math.abs(velY)\n                \n                if sumVel > 20 then\n                    table.insert(self.destroyedBodies, b:getBody())\n                end\n            else\n                local velX, velY = b:getBody():getLinearVelocity()\n                local sumVel = math.abs(velX) + math.abs(velY)\n\n                if sumVel > 20 then\n                    table.insert(self.destroyedBodies, a:getBody())\n                end\n            end\n        end\n\n        -- if we hit the ground, play a bounce sound\n        if types['Player'] and types['Ground'] then\n            gSounds['bounce']:stop()\n            gSounds['bounce']:play()\n        end\n    end\n\n    -- the remaining three functions here are sample definitions, but we are not\n    -- implementing any functionality with them in this demo; use-case specific\n    function endContact(a, b, coll)\n        \n    end\n\n    function preSolve(a, b, coll)\n\n    end\n\n    function postSolve(a, b, coll, normalImpulse, tangentImpulse)\n\n    end\n\n    -- register just-defined functions as collision callbacks for world\n    self.world:setCallbacks(beginContact, endContact, preSolve, postSolve)\n\n    -- shows alien before being launched and its trajectory arrow\n    self.launchMarker = AlienLaunchMarker(self.world)\n\n    -- aliens in our scene\n    self.aliens = {}\n\n    -- obstacles guarding aliens that we can destroy\n    self.obstacles = {}\n\n    -- simple edge shape to represent collision for ground\n    self.edgeShape = love.physics.newEdgeShape(0, 0, VIRTUAL_WIDTH * 3, 0)\n\n    -- spawn an alien to try and destroy\n    table.insert(self.aliens, Alien(self.world, 'square', VIRTUAL_WIDTH - 80, VIRTUAL_HEIGHT - TILE_SIZE - ALIEN_SIZE / 2, 'Alien'))\n\n    -- spawn a few obstacles\n    table.insert(self.obstacles, Obstacle(self.world, 'vertical',\n        VIRTUAL_WIDTH - 120, VIRTUAL_HEIGHT - 35 - 110 / 2))\n    table.insert(self.obstacles, Obstacle(self.world, 'vertical',\n        VIRTUAL_WIDTH - 35, VIRTUAL_HEIGHT - 35 - 110 / 2))\n    table.insert(self.obstacles, Obstacle(self.world, 'horizontal',\n        VIRTUAL_WIDTH - 80, VIRTUAL_HEIGHT - 35 - 110 - 35 / 2))\n\n    -- ground data\n    self.groundBody = love.physics.newBody(self.world, -VIRTUAL_WIDTH, VIRTUAL_HEIGHT - 35, 'static')\n    self.groundFixture = love.physics.newFixture(self.groundBody, self.edgeShape)\n    self.groundFixture:setFriction(0.5)\n    self.groundFixture:setUserData('Ground')\n\n    -- background graphics\n    self.background = Background()\nend\n\nfunction Level:update(dt)\n    -- update launch marker, which shows trajectory\n    self.launchMarker:update(dt)\n\n    -- Box2D world update code; resolves collisions and processes callbacks\n    self.world:update(dt)\n\n    -- destroy all bodies we calculated to destroy during the update call\n    for k, body in pairs(self.destroyedBodies) do\n        if not body:isDestroyed() then \n            body:destroy()\n        end\n    end\n\n    -- reset destroyed bodies to empty table for next update phase\n    self.destroyedBodies = {}\n\n    -- remove all destroyed obstacles from level\n    for i = #self.obstacles, 1, -1 do\n        if self.obstacles[i].body:isDestroyed() then\n            table.remove(self.obstacles, i)\n\n            -- play random wood sound effect\n            local soundNum = math.random(5)\n            gSounds['break' .. tostring(soundNum)]:stop()\n            gSounds['break' .. tostring(soundNum)]:play()\n        end\n    end\n\n    -- remove all destroyed aliens from level\n    for i = #self.aliens, 1, -1 do\n        if self.aliens[i].body:isDestroyed() then\n            table.remove(self.aliens, i)\n            gSounds['kill']:stop()\n            gSounds['kill']:play()\n        end\n    end\n\n    -- replace launch marker if original alien stopped moving\n    if self.launchMarker.launched then\n        local xPos, yPos = self.launchMarker.alien.body:getPosition()\n        local xVel, yVel = self.launchMarker.alien.body:getLinearVelocity()\n        \n        -- if we fired our alien to the left or it's almost done rolling, respawn\n        if xPos < 0 or (math.abs(xVel) + math.abs(yVel) < 1.5) then\n            self.launchMarker.alien.body:destroy()\n            self.launchMarker = AlienLaunchMarker(self.world)\n\n            -- re-initialize level if we have no more aliens\n            if #self.aliens == 0 then\n                gStateMachine:change('start')\n            end\n        end\n    end\nend\n\nfunction Level:render()\n    -- render ground tiles across full scrollable width of the screen\n    for x = -VIRTUAL_WIDTH, VIRTUAL_WIDTH * 2, 35 do\n        love.graphics.draw(gTextures['tiles'], gFrames['tiles'][12], x, VIRTUAL_HEIGHT - 35)\n    end\n\n    self.launchMarker:render()\n\n    for k, alien in pairs(self.aliens) do\n        alien:render()\n    end\n\n    for k, obstacle in pairs(self.obstacles) do\n        obstacle:render()\n    end\n\n    -- render instruction text if we haven't launched bird\n    if not self.launchMarker.launched then\n        love.graphics.setFont(gFonts['medium'])\n        love.graphics.setColor(0, 0, 0, 255)\n        love.graphics.printf('Click and drag circular alien to shoot!',\n            0, 64, VIRTUAL_WIDTH, 'center')\n        love.graphics.setColor(255, 255, 255, 255)\n    end\n\n    -- render victory text if all aliens are dead\n    if #self.aliens == 0 then\n        love.graphics.setFont(gFonts['huge'])\n        love.graphics.setColor(0, 0, 0, 255)\n        love.graphics.printf('VICTORY', 0, VIRTUAL_HEIGHT / 2 - 32, VIRTUAL_WIDTH, 'center')\n        love.graphics.setColor(255, 255, 255, 255)\n    end\nend
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/Level.lua	(revision 2adefa677b5e80aabebe1cb6173c72c4d1b493d7)
+++ src/Level.lua	(date 1590352624794)
@@ -21,23 +21,30 @@
     -- one for different stages of any given collision
     function beginContact(a, b, coll)
         local types = {}
-        types[a:getUserData()] = true
-        types[b:getUserData()] = true
+        types[a:getUserData().type] = true
+        types[b:getUserData().type] = true
+
+        --print('a type: ' .. a:getUserData().type)
+        --print('b type: ' .. b:getUserData().type)
 
         -- if we collided between both an alien and an obstacle...
         if types['Obstacle'] and types['Player'] then
-
+            print("collision between player and obstacle")
             -- destroy the obstacle if player's combined velocity is high enough
             if a:getUserData() == 'Obstacle' then
+                b:getUserData().hasCollided = true
                 local velX, velY = b:getBody():getLinearVelocity()
                 local sumVel = math.abs(velX) + math.abs(velY)
+                print('sumVel: ' .. sumVel)
 
                 if sumVel > 20 then
                     table.insert(self.destroyedBodies, a:getBody())
                 end
             else
+                a:getUserData().hasCollided = true
                 local velX, velY = a:getBody():getLinearVelocity()
                 local sumVel = math.abs(velX) + math.abs(velY)
+                print('sumVel: ' .. sumVel)
 
                 if sumVel > 20 then
                     table.insert(self.destroyedBodies, b:getBody())
@@ -71,6 +78,7 @@
 
             -- destroy the alien if player is traveling fast enough
             if a:getUserData() == 'Player' then
+                a:getUserData().hasCollided = true
                 local velX, velY = a:getBody():getLinearVelocity()
                 local sumVel = math.abs(velX) + math.abs(velY)
                 
@@ -78,6 +86,7 @@
                     table.insert(self.destroyedBodies, b:getBody())
                 end
             else
+                b:getUserData().hasCollided = true
                 local velX, velY = b:getBody():getLinearVelocity()
                 local sumVel = math.abs(velX) + math.abs(velY)
 
@@ -89,6 +98,11 @@
 
         -- if we hit the ground, play a bounce sound
         if types['Player'] and types['Ground'] then
+            if a:getUserData() == 'Player' then
+                a:getUserData().hasCollided = true
+            else
+                b:getUserData().hasCollided = true
+            end
             gSounds['bounce']:stop()
             gSounds['bounce']:play()
         end
@@ -124,7 +138,8 @@
     self.edgeShape = love.physics.newEdgeShape(0, 0, VIRTUAL_WIDTH * 3, 0)
 
     -- spawn an alien to try and destroy
-    table.insert(self.aliens, Alien(self.world, 'square', VIRTUAL_WIDTH - 80, VIRTUAL_HEIGHT - TILE_SIZE - ALIEN_SIZE / 2, 'Alien'))
+    --table.insert(self.aliens, Alien(self.world, 'square', VIRTUAL_WIDTH - 80, VIRTUAL_HEIGHT - TILE_SIZE - ALIEN_SIZE / 2, 'Alien'))
+    table.insert(self.aliens, Alien(self.world, 'square', VIRTUAL_WIDTH - 80, VIRTUAL_HEIGHT - TILE_SIZE - ALIEN_SIZE / 2, {type = 'Alien', hasCollided = false}))
 
     -- spawn a few obstacles
     table.insert(self.obstacles, Obstacle(self.world, 'vertical',
@@ -138,7 +153,8 @@
     self.groundBody = love.physics.newBody(self.world, -VIRTUAL_WIDTH, VIRTUAL_HEIGHT - 35, 'static')
     self.groundFixture = love.physics.newFixture(self.groundBody, self.edgeShape)
     self.groundFixture:setFriction(0.5)
-    self.groundFixture:setUserData('Ground')
+    --self.groundFixture:setUserData('Ground')
+    self.groundFixture:setUserData({type = 'Ground'})
 
     -- background graphics
     self.background = Background()
Index: src/Obstacle.lua
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>--[[\n    GD50\n    Angry Birds\n\n    Author: Colton Ogden\n    cogden@cs50.harvard.edu\n\n    An Obstacle is any physics-based construction that forms the current level,\n    usually shielding the aliens the player is trying to kill; they can form houses,\n    boxes, anything the developer wishes. Depending on what kind they are, they are\n    typically rectangular or polygonal.\n]]\n\nObstacle = Class{}\n\nfunction Obstacle:init(world, shape, x, y)\n    self.shape = shape or 'horizontal'\n\n    if self.shape == 'horizontal' then\n        self.frame = 2\n    elseif self.shape == 'vertical' then\n        self.frame = 4\n    end\n\n    self.startX = x\n    self.startY = y\n\n    self.world = world\n\n    self.body = love.physics.newBody(self.world, \n        self.startX or math.random(VIRTUAL_WIDTH), self.startY or math.random(VIRTUAL_HEIGHT - 35), 'dynamic')\n\n    -- assign width and height based on shape to create physics shape\n    if self.shape == 'horizontal' then\n        self.width = 110\n        self.height = 35\n    elseif self.shape == 'vertical' then\n        self.width = 35\n        self.height = 110\n    end\n\n    self.shape = love.physics.newRectangleShape(self.width, self.height)\n\n    self.fixture = love.physics.newFixture(self.body, self.shape)\n\n    self.fixture:setUserData('Obstacle')\nend\n\nfunction Obstacle:update(dt)\n\nend\n\nfunction Obstacle:render()\n    love.graphics.draw(gTextures['wood'], gFrames['wood'][self.frame],\n        self.body:getX(), self.body:getY(), self.body:getAngle(), 1, 1,\n        self.width / 2, self.height / 2)\nend
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/Obstacle.lua	(revision 2adefa677b5e80aabebe1cb6173c72c4d1b493d7)
+++ src/Obstacle.lua	(date 1590352166897)
@@ -43,7 +43,8 @@
 
     self.fixture = love.physics.newFixture(self.body, self.shape)
 
-    self.fixture:setUserData('Obstacle')
+    self.fixture:setUserData({ type = 'Obstacle'})
+    --self.fixture:setUserData('Obstacle')
 end
 
 function Obstacle:update(dt)
Index: src/AlienLaunchMarker.lua
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>--[[\n    GD50\n    Angry Birds\n\n    Author: Colton Ogden\n    cogden@cs50.harvard.edu\n]]\n\nAlienLaunchMarker = Class{}\n\nfunction AlienLaunchMarker:init(world)\n    self.world = world\n\n    -- starting coordinates for launcher used to calculate launch vector\n    self.baseX = 90\n    self.baseY = VIRTUAL_HEIGHT - 100\n\n    -- shifted coordinates when clicking and dragging launch alien\n    self.shiftedX = self.baseX\n    self.shiftedY = self.baseY\n\n    -- rotation for the trajectory arrow\n    self.rotation = 0\n\n    -- whether our arrow is showing where we're aiming\n    self.aiming = false\n\n    -- whether we launched the alien and should stop rendering the preview\n    self.launched = false\n\n    -- our alien we will eventually spawn\n    self.alien = nil\nend\n\nfunction AlienLaunchMarker:update(dt)\n    \n    -- perform everything here as long as we haven't launched yet\n    if not self.launched then\n\n        -- grab mouse coordinates\n        local x, y = push:toGame(love.mouse.getPosition())\n        \n        -- if we click the mouse and haven't launched, show arrow preview\n        if love.mouse.wasPressed(1) and not self.launched then\n            self.aiming = true\n\n        -- if we release the mouse, launch an Alien\n        elseif love.mouse.wasReleased(1) and self.aiming then\n            self.launched = true\n\n            -- spawn new alien in the world, passing in user data of player\n            self.alien = Alien(self.world, 'round', self.shiftedX, self.shiftedY, 'Player')\n\n            -- apply the difference between current X,Y and base X,Y as launch vector impulse\n            self.alien.body:setLinearVelocity((self.baseX - self.shiftedX) * 10, (self.baseY - self.shiftedY) * 10)\n\n            -- make the alien pretty bouncy\n            self.alien.fixture:setRestitution(0.4)\n            self.alien.body:setAngularDamping(1)\n\n            -- we're no longer aiming\n            self.aiming = false\n\n        -- re-render trajectory\n        elseif self.aiming then\n            self.rotation = self.baseY - self.shiftedY * 0.9\n            self.shiftedX = math.min(self.baseX + 30, math.max(x, self.baseX - 30))\n            self.shiftedY = math.min(self.baseY + 30, math.max(y, self.baseY - 30))\n        end\n    end\nend\n\nfunction AlienLaunchMarker:render()\n    if not self.launched then\n        \n        -- render base alien, non physics based\n        love.graphics.draw(gTextures['aliens'], gFrames['aliens'][9], \n            self.shiftedX - 17.5, self.shiftedY - 17.5)\n\n        if self.aiming then\n            \n            -- render arrow if we're aiming, with transparency based on slingshot distance\n            local impulseX = (self.baseX - self.shiftedX) * 10\n            local impulseY = (self.baseY - self.shiftedY) * 10\n\n            -- draw 6 circles simulating trajectory of estimated impulse\n            local trajX, trajY = self.shiftedX, self.shiftedY\n            local gravX, gravY = self.world:getGravity()\n\n            -- http://www.iforce2d.net/b2dtut/projected-trajectory\n            for i = 1, 90 do\n                \n                -- magenta color that starts off slightly transparent\n                love.graphics.setColor(255, 80, 255, (255 / 12) * i)\n                \n                -- trajectory X and Y for this iteration of the simulation\n                trajX = self.shiftedX + i * 1/60 * impulseX\n                trajY = self.shiftedY + i * 1/60 * impulseY + 0.5 * (i * i + i) * gravY * 1/60 * 1/60\n\n                -- render every fifth calculation as a circle\n                if i % 5 == 0 then\n                    love.graphics.circle('fill', trajX, trajY, 3)\n                end\n            end\n        end\n        \n        love.graphics.setColor(255, 255, 255, 255)\n    else\n        self.alien:render()\n    end\nend
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/AlienLaunchMarker.lua	(revision 2adefa677b5e80aabebe1cb6173c72c4d1b493d7)
+++ src/AlienLaunchMarker.lua	(date 1590352107448)
@@ -49,7 +49,8 @@
             self.launched = true
 
             -- spawn new alien in the world, passing in user data of player
-            self.alien = Alien(self.world, 'round', self.shiftedX, self.shiftedY, 'Player')
+            self.alien = Alien(self.world, 'round', self.shiftedX, self.shiftedY, {type = 'Player', hasCollided = false})
+            --self.alien = Alien(self.world, 'round', self.shiftedX, self.shiftedY, 'Player')
 
             -- apply the difference between current X,Y and base X,Y as launch vector impulse
             self.alien.body:setLinearVelocity((self.baseX - self.shiftedX) * 10, (self.baseY - self.shiftedY) * 10)
